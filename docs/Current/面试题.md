# 多线程

线程是处理器任务调度时的单位。进程是操作系统的资源分配的单元

一个进程挂掉了，不会对其他进程造成太大的影响；一个线程挂掉够，会让整个进程崩溃的。所以多进程是比多线程要更健壮的。一个进程的线程之间是共享地址空间和资源的。而进程之间的地址空间和资源是相互独立的

创建线程的方式 实现Runnable、Callable、继承Thread

使用实现接口的方式的话，多个线程可以共享一个target对象。比较适合多个相同的线程来处理同一份资源的情况，将CPU、代码和数据都分开。   劣势：编译复杂了，要访问当前线程的话，就必须Thread.currentThread方法

使用继承的方式，编写简单，直接this就可以了，   劣势：java是单继承的

### Runnable和Callable的区别

Callable规定重写的方法是call().Runnable规定重写的方法是run()

Callable 可以有返回值，借助FutureTask类来获取返回的结果

Call方法可以抛出异常，run不行

运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的完成。通过Future 对象可以了解任务执行的情况，可取消任务的执行，还可以获取执行结果

```java
//创建线程要执行的任务
MyThread myThread = new MyThread();
//Callable接口实现的要靠FutureTask来转换一下
FutureTask<Integer> futureTask = new FutureTask<>(myThread);
//转换后的任务创建为线程
Thread thread = new Thread(futureTask);
//启动线程
thread.start();
//通过FutureTask可以获得线程里面的返回值。
Integer integer = futureTask.get();
```



### 为什么使用多线程

从计算机底层来说，线程是可以比作是轻量级的进程，是程序运行的最小单位，线程之间的切换和调度时远远比小于进程的。多核CPU意味着多个线程是可以同步执行的，这就更大大的减少了线程之间的上下文切换

多线程并发编程是现在开发高并发系统的基础。

在单核时代多线程主要是为了提高CPU和IO之间的设备利用率；多核时代为了提高CPU的利用率

### 线程的生命周期

新建、就绪、运行、阻塞、死亡

阻塞：等待阻塞，遇到wait()方法，使线程进入到等待阻塞的状态。同步阻塞，线程在获取synchronized同步的时候失败了（锁被其他的占用这）。其他阻塞：通过调用线程的sleep()或join()方法或发出IO请求时

### 死锁

互斥条件：该资源任意一个时刻只能有一个线程占有

请求和保持条件：一个进程因请求资源而阻塞的，对已获得的资源保持不放

不剥夺条件：线程在已获得的资源在未使用完之前不能被其他线程强行剥夺。只有自己使用完毕后才释放资源

循环等待条件：若干个进程之间形成一种头尾相接的循环等待资源确认就可以了

**避免**：

互斥条件避免不了

破坏请求和保持条件：一次就申请所有的资源。 破坏不剥夺条件：进一步申请资源的时候，申请不到，释放手里所有资源。 破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放，破坏循环等待条件。  锁排方法：指定获取锁的顺序，比如某个线程在只有同时获得A锁个B锁的情况下，才可以对某写元素进行操作。在多线程条件下，通过指定锁的获取顺序，比如规定，只有获得A锁的线程才有资格获得B锁，按顺序获取锁就可以避免锁。  使用显示锁中的ReentrantLock,try(long,TimeUnit)来申请锁。

### Runnable和Callable

Callable仅在jdk1.7中引入，目的就是为了来处理Runnable不支持的。Callable接口是可以返回结果或抛出检查异常的。

Runnable接口是不会返回结果或抛出异常的

如果任务不需要返回结果或抛出异常就推荐使用Runnable。代码简洁

### shutdown和shutdownNow

shutdown是关闭线程池，线程池不会再接受新的任务，但是在队列当中中的任务要执行完，线程池的状态就变为shutdown

shutdownNow 线程池的状态就变为stop状态，线程池会终止当前正在运行的任务，并停止处理线程池中的任务，并返回正在等待的list，  原理就是变量线程池中的工作线程，然后逐个调用线程的 interrupt 方法来中断线程，所以无法响应中断的任务可能永远无法终止

### isTerminated和isShutdown的区别

isShutDown 调用 shutdown 方法后返回true

isTerminated 调用shutdown 方法后，并且所有提交的任务完成后返回true。

### sleep和wait

sleep方法，是Thread类的静态方法，让当前线程睡眠多少秒，线程进入阻塞状态，时间结束进入就绪状态，睡眠过程是不释放锁的。

wait方法，是Object类的方法，必须是与synchronized一起使用的，线程进入阻塞状态，当notify或notifyall被调用后，会结束阻塞，但是只有重新占用互斥锁之后才可以进入就绪状态，睡眠的时候，会释放互斥锁。

sleep不释放锁，wait释放锁

sleep通常用于暂停 wait通常用于线程之间交互/通信

sleep方法执行完成之后，线程会自动苏醒，或者可以使用wait(long timeout)超时的时候线程会自动苏醒的，wait方法被调用之后，线程不会自动苏醒，需要别的线程调用同一对象去唤醒。

两个都可以暂停线程的执行。

### 为什么调用start方法时会执行run方法，不直接调用run方法

在new一个Thread的时候，线程进入了新建状态；调用start会执行线程的相应准备工作，然后再自动执行run方法，（就是在调用start方法的时候，会启动一个线程并使线程进入就绪状态，当分配到时间片之后就开始运行）

执行执行run方法的话，是不会创建线程的，会把run方法当做一个main线程下的普通方法去执行，并不会再某个线程中执行它

### Thread中的yield方法

这个方法会暂停当前正在执行的线程对象，让其他有相同优先级的线程执行，是一个静态方法，而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用上CPU，执行yield线程可能在进入到暂停状态后马上就执行

### volatile

volatile方法：保证变量对所有线程的可见性，当volatile变量被修改的时候，新值就会对所有的线程通知立即更新。或者在多线程情况之下使用了volatile修饰的变量的值一定是最新的

在jdk5之后volatile完全避免了指令重排优化，实现了有序性

**原理**：获取JIT（java编译器）的汇编代码，发现volatile多加了lock addl指令，这个操作相当于一个内存的屏障使得lock指令后的指令不能重排序到内存屏障前的位置。也是在jdk5之后可以使用双锁检测实现单例模式。lock前缀的另一层含义就是使得本线程内存中的volatile变量值立即写入到主内存当中，并且使得其他线程共享该volatile变量无效化。使得其他线程必须重新从主内存中读取该变量值。

### 线程阻塞的三种情况

等待阻塞 RUNNING 状态的线程执行Object.wait方法，JVM会将线程放入等待序列

同步阻塞 在获取对象的同步锁的时候，若该同步锁被其他线程占用着，则JVM就将线程放入锁池当中	。

其他阻塞 执行sleep、wait、发出IO请求，JVM会将其设置为阻塞状态

### 线程死亡的三种情况

正常结束 run或call方法执行完

异常结束 线程抛出一个未捕获的Exception 或Error，导致线程异常结束

调用stop方法。这个方法容易造成死锁

### Fork/Join框架

设置JDK7之后提供的一个用于并行执行任务的框架，是一个把大任务分割为若干个小任务，最终汇总每个小任务结果后得到的大任务结果的框架

**分而治之**和**工作窃取算法**

工作：在把大任务拆分为小任务的时候，放到不同的队列执行的时候，交由不同的线程分别执行的时候，有的线程优先把自己负责的任务执行完了，其他线程还在慢悠悠处理自己的任务，这时为了提高自己的效率就用到这个算法

某个线程从其他队列中窃取任务进行执行，一般是做的快的线程抢慢的线程任务做，为了减少锁竞争，采用的是双端队列

### CAS

即比较并交换，是一条CPU同步原语，是一种硬件对并发的操作，针对多处理器操作而设计的一种特殊的指令

CAS就是一种无锁的非阻塞算法的实现

3个操作数：需要读写的内存值V，旧的预期值A，要修改的更新值B

当且仅当V的值等于A的时候，CAS通过原子方式用新值B来更新V的值，否则就不会执行任何操作（它的功能就是判断内存某个位置的值是否为预期值，如果是则更改，这就是原子性）

JVM是帮助我们执行CAS汇编指令，一种依赖于硬件的功能，是由若干条指令发布的。用于完成某个功能的一部分，并且原语的执行必须是连续的，在执行过程中不允许被中断，CAS是一条CPU的原子指令。

**缺陷**

ABA问题： 通过AtomicStampedReference去解决这个问题的，就是带有标记的原子应用类，通过控制变量的值来保证CAS的正确性

循环时间长开销 自旋的CAS，如果一直循环，会给CPU带来非常大的执行开销。在这个里面加上自旋次数

只能保证一个变量的原子操作。  如果对多个变量操作的时候，CAS是无法直接保证操作的原子性操作的。

通过互斥锁来保证原子性。将多个变量疯转为一个对象，通过AtomicReference来保证原子性。

### synchronized和volatile

volatile是保证可见性的，synchronized是解决是执行控制的问题，它会阻止其他线程获取当前对象的监控，这样一来就让当前对象中被synchronized关键字保护的代码块无法被其他线程访问，也就是无法并行执行

synchronized会创建一个内存屏障，内存屏障执行保证了所有CPU操作结果都会执行刷到主存当中，从而保证操作的内存可见性。

区别

1. volatile本质是告诉JVM当前变量在寄存器中的值是不确定的，需要从主存中读取，synchronized 则是锁当前变量，只有当前线程可以访问该变量，其他线程被阻塞
2. volatile仅能使用在变量级别的，synchronized则可以使用在变量、方法和类级别当中
3. volatile仅能实现变量的修改可见性，不能保证原子性，synchronized是都可以的
4. volatile不会造成线程阻塞，synchronized可以
5. volatile标记的变量不会被编译器优化，synchronized可以被编译器优化

### synchronized和lock

synchronized可以给类、方法、代码块加锁。lock只能给代码块加锁

synchronized不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁。Lock需要自己去加锁和释放锁，如果使用不当的没有unLock去释放锁的话，会造成死锁

通过Lock可以知道有没有成功获取锁，而synchronized却无法办到

### synchronized和ReentrantLock

都是可重入锁，在一个线程中可以多次获取同一把锁，一个线程在执行的时候，调用了另一个带有相同锁的方法，无须重新获得锁，直接运行，没进入一个线程，锁的计数器就加1。

synchronized依赖于JVM，ReentrantLock依赖于API（需要lock和unlock配合try/finally 去做

ReentrantLock比synchronized高级一点：

等待可中断。通过lock.lockInterruptibly来实现这个机制，也就是说正在等待的线程可以选择放弃等待

可实现公平锁，先等待的线程先获得锁，通过ReentrantLock(boolean fair)构造方法来实现是否公平（默认非公平

可实现选择性通知，ReentrantLock类线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。    在使用notify/notifyAll方法进行通知。被通知的线程是由JVM选择的。用ReentrantLock结合Condition实例可以实现“选择性通知”

### synchronized

修饰普通方法、静态方法、代码块

原子性：确保线程互斥  

可见性：对一个变量unlock操作之前，必须要同步到主内存中，如果一个变量进行lock操作，就清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主存中load操作或assign操作初始化变量值

有序性：一个unlock操作先行发生（happen-before）于后面对同一个锁的lock操作。

