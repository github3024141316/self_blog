
# 缓存的处理流程
1. 前端发送请求，请求先到达redis，在redis缓存中查询是否有该数据，有就返回，没有就去数据库中查询。
2. 在数据库中查询，数据库中有数据，同步到redis缓存，同时返回给前端。没有数据返回空。

# 缓存穿透
## 穿透的原因
请求的数据在redis缓存中不存在，数据库中也没有该数据，请求每次直接穿透打在数据库中。

例：查询数据库中id为`-1`的数据，每次都会穿透redis访问数据库，大量恶意请求可能导致数据库挂掉。
![在这里插入图片描述](https://img-blog.csdnimg.cn/dd658d6262b344eea5f11c28c8682a5e.png)


总结：**缓存和数据库中都没有该数据**。
## 如何解决穿透？

1. 将空对象返回给前端，并将空对象同步到缓存中。（给空对象设置较短的过期时间）
2. 检验参数的合法性，不合法直接return
3. 使用布隆过滤器
# 缓存击穿
## 击穿的原因
大量请求访问热点key，若key到期失效了，此时大量的请求直接到达数据库，可能导致数据库挂掉。
![在这里插入图片描述](https://img-blog.csdnimg.cn/7831daa86c274761bdf8f13541935572.png)

## 如何解决击穿？
1. 设置key永久有效
2. 这种情况是多个线程同时到达数据库查询该数据。可以给第一个请求的线程上锁。
	1. 在第一个请求的线程上加互斥锁，其他线程等着
	2. 持有锁的第一个线程查询到了数据，将数据同步到redis缓存
	3. 后面的线程在redis中查询到了数据，就不会到达数据库发生击穿了


# 缓存雪崩
## 雪崩的原因
在高并发下，大量redis缓存在同一时间失效到期或redis故障，所有的请求都会到达数据库，可能导致数据库挂掉。
![在这里插入图片描述](https://img-blog.csdnimg.cn/c09719f264cf48dea698a576a1bd5b79.png)

## 如何解决雪崩？
1. **不设置过期时间**，默认永久有效，就不会发生雪崩了，但是浪费内存。
2. 既然是同一时间失效导致的雪崩，我们**随机初始key的过期时间**，避免大量Key同时过期。
3. 如果redis集群，将**热点key平均分布到不同的redis结点**上去，避免集体失效。
4. **定时任务**，在缓存失效前将缓存重新跑进去。

# 总结：
缓存穿透是**缓存和数据库中都没有**数据，一直查询数据库
缓存击穿是**热点key突然失效**，大量请求到达数据库
缓存雪崩是**大面积**(大量)key**同时**失效，大量请求到达数据库

# 如何避免redis宕机，请求全到达数据库的情况？
- 未宕机 ：redis的高可用性（主从复制+哨兵机制），避免redis挂掉
- 已宕机 ：redis宕机，设置本地缓存(ehcahe + 限流)，避免请求全走数据库
- 宕机后 ：redis持久化，重启后将数据从磁盘中加载到内存中来

