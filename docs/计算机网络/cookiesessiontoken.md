**1.session****和cookie区别：**

·   数据存放位置不同：Session数据是存在服务器中的，cookie数据存放在浏览器当中。

·   安全程度不同：cookie放在服务器中不是很安全，session放在服务器中，相对安全。

·   性能使用程度不同：session放在服务器上，访问增多会占用服务器的性能；考虑到减轻服务器性能方面，应使用cookie。

·   数据存储大小不同：单个cookie保存的数据不能超过4K，session存储在服务端，根据服务器大小来定。

**2.token****和session区别：**

·   token是开发定义的，session是http协议规定的；

·   token不一定存储，session存在服务器中；

·   token可以跨域，session不可以跨域，它是与域名绑定的。

#### 什么是会话？

会话： 数据交互的过程，在web中指 浏览器从发出一个请求到浏览器关闭，这个过程就是一个会话。在这个过程中，需要有很多的状态和数据需要我们关注，记录，这个就是我们要研究的会话

#### 什么是会话机制

http协议是短连接无状态的，所以需要cookie和session进行保存用户身份验证
 从根本上解决了用户持续访问的问题
 cookie服务器下发保存在本地的，因此cookie不安全，容易被篡改
 cookie是临时的，关闭浏览器自动删除
 因此需要session，session是生成在服务器，django保存在数据库，flask保存在服务器的，把session id给用户下发

#### 什么是cookie

cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。
 cookie由服务器生成，发送给浏览器，浏览器把cookie以`key,value`形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。
 总结：cookie是一段小型文本数据
 Cookie是一段不超过4KB的小型[文本](https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E6%96%87%E6%9C%AC%2F5443630)数据，由一个名称（Name）、一个值（Value）和其它几个用于控制Cookie有效期、安全性、使用范围的可选属性组成。

#### 什么是session

session 从字面上讲，就是会话。这个就类似于你和一个人交谈，你怎么知道当前和你交谈的是张三而不是李四呢？对方肯定有某种特征（长相等）表明他就是张三。

session 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。

服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，

可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。

#### 什么是token？	 

1、Token的引入：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，

判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。

2、Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生

成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。

3、使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。

#### 如何使用token？

###### 1、用设备号/设备mac地址作为Token（推荐）

客户端：客户端在登录的时候获取设备的设备号/mac地址，并将其作为参数传递到服务端。

服务端：服务端接收到该参数后，便用一个变量来接收同时将其作为Token保存在数据库，并将该Token设置到

session中，客户端每次请求的时候都要统一拦截，并将客户端传递的token和服务器端session中的token进行对比，

如果相同则放行，不同则拒绝。

分析：此刻客户端和服务器端就统一了一个唯一的标识Token，而且保证了每一个设备拥有了一个唯一的会话。

该方法的缺点是客户端需要带设备号/mac地址作为参数传递，而且服务器端还需要保存；优点是客户端不需重新登录，

只要登录一次以后一直可以使用，至于超时的问题是有服务器这边来处理，如何处理？若服务器的Token超时后，

服务器只需将客户端传递的Token向数据库中查询，同时并赋值给变量Token，如此，Token的超时又重新计时。

###### 2、用session值作为Token

客户端：客户端只需携带用户名和密码登陆即可。

客户端：客户端接收到用户名和密码后并判断，如果正确了就将本地获取sessionID作为Token返回给客户端，

客户端以后只需带上请求数据即可。

分析：这种方式使用的好处是方便，不用存储数据，但是缺点就是当session过期后，

客户端必须重新登录才能进行访问数据。

#### token的优势

###### 无状态、可扩展

在客户端存储的Tokens是无状态的，并且能够被扩展。基于这种无状态和不存储Session信息，

负载负载均衡器能够将用户信息从一个服务传到其他服务器上。
 如果我们将已验证的用户的信息保存在Session中，

则每次请求都需要用户向已验证的服务器发送验证信息(称为Session亲和性)。

用户量大时，可能会造成一些拥堵。
 但是不要着急。使用tokens之后这些问题都迎刃而解，

因为tokens自己hold住了用户的验证信息。

###### 安全性

请求中发送token而不再是发送cookie能够防止CSRF(跨站请求伪造)。即使在客户端使用cookie存储token，

cookie也仅仅是一个存储机制而不是用于认证。不将信息存储在Session中，让我们少了对session操作。
 token是有时效的，一段时间之后用户需要重新验证。我们也不一定需要等到token自动失效，token有撤回的操作，

通过token revocataion可以使一个特定的token或是一组有相同认证的token无效。

###### 可扩展性

Tokens能够创建与其它程序共享权限的程序。例如，能将一个随便的社交帐号和自己的大号(Fackbook或是Twitter)联系起来。

当通过服务登录Twitter(我们将这个过程Buffer)时，我们可以将这些Buffer附到Twitter的数据流上(we are allowing Buffer to post to our Twitter stream)。

使用tokens时，可以提供可选的权限给第三方应用程序。当用户想让另一个应用程序访问它们的数据，

我们可以通过建立自己的API，得出特殊权限的tokens。

###### 多平台跨域

我们提前先来谈论一下CORS(跨域资源共享)，对应用程序和服务进行扩展的时候，

需要介入各种各种的设备和应用程序。
 Having our API just serve data, we can also make the design choice to serve assets from a CDN. This eliminates the issues that CORS brings up after we set a quick header configuration for our application.

只要用户有一个通过了验证的token，数据和资源就能够在任何域上被请求到。

```
Access-Control-Allow-Origin: *
```

#### 有何区别？

这里就讲述一下session与token的区别，这里以一个flask项目举例，session是把flask存在服务器的，服务器存放一个session值，像前端下发一个key，然后前端访问的时候会携带这个key进行访问，再去服务器寻找key对应的值，如果找到了就校验成功，这是一个项目生成与下发session的具体流程。
 这时对于这个session校验就会产生一个问题，如果我们这个项目做了负载均衡，后端采用多台服务器放置数据呢？用户每次登陆会被引向不同的服务器，这时候还要校验用户身份是不是就需要每台服务器都存放一个session对应的value呢？为了解决这个问题，就不再使用session校验，而是使用token，在token技术里，服务器端存放一个加密校验方式，不存放任何用户的session之类的数据，用户访问服务器，在服务器端生成一个加密后的返回一个带签名的token下发给前端，前端页面保存这个token，以后每次访问在请求头`heads`中携带这个token进行访问就可以了。服务端会验证token，校验成功则返回请求数据，校验失败则返回错误码。至此，因为是服务器不存放value值，所以不用一一对应前端的key和后端的value，因此也就解决了跨域访问的问题，也解决了负载均衡下多台服务器的问题。