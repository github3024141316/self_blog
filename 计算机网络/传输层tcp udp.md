## UDP

![在这里插入图片描述](https://img-blog.csdnimg.cn/8a34daa8bfaa4b2380a2d2c9f6e1b811.png)
- 目标端口号：接收进程的端口
- 源端口号：发送进程的端口
- 包长度：保存 首部长度 与 数据长度 之和
- 校验和：设计可靠的UDP首部和数据

概述：
- 将数据、源端口、目的端口封装成数据包，不需要建立连接

- 每个数据报的大小限制在64K内
- 因无需连接，故是**不可靠**的
- 发送数据结束时不需要释放资源，速度快

## TCP
### 概述
TCP是面向连接、可靠的、基于字节流的传输层通信协议。

- 面向连接：**一对一**，两台设备之间建立连接
- 可靠的：总能保证报文一定能送达接收方
- 基于字节流：数据是`没有大小限制的`、`有序的`、如果**先收到数据后面的字节**，不会立即发送给对方，等待接收完毕，再**丢弃重复的字节**，最后发送出去完整不重复的数据。

### TCP与UDP的区别
连接
- TCP是**面向连接的**，就像打视频电话，需要先打通对方电话，等待对方有回应后才会跟对方继续说话，也就是**一定要确认可以发信息以后才会把信息发出去**。TCP上传任何东西都是可靠的，只要两台机器上建立起了连接，在本机上发送的数据就一定能传到对方的机器上。

- UDP是**无连接的**；就像发邮件，只负责发送出去，不管对方有没有收到，所以UDP是不可靠的。

可靠性
- TCP传送数据**可靠**，但是消耗更多的资源，传送得比较**慢**。
- UDP传送数据**不可靠**，但是使用更少的资源，传送得**快**。

连接对象
- TCP只能是两台设备之间互相收发数据
- UDP可以一对一、一对多、多对多

拥塞控制、流量控制
- TCP有拥塞控制和流量控制机制
- UDP没有，网络拥堵也不会影响UDP的速率

传输的方式

- TCP是基于字节流传输，保证了数据的**有序性**和**完整性**
- UDP是按每个包发送，有大小限制，可能会有**丢包、乱序**的问题

应用场景
- TCP用于 `FTP` 文件传输、`HTTP/HTTPS`
- UDP用于DNS、SNMP、视频、音频、广播

![在这里插入图片描述](https://img-blog.csdnimg.cn/933763cad4404804b965b506e768080d.png)
**UDP为什么没有首部长度？**
- 	TCP有可变长的【选项】字段，UDP头部长度是固定的，不用专门使用一个字段来记录

**TCP为什么没有包长度？**
TCP和UDP是基于IP的，两个数据长度计算方法类似
- ` TCP数据长度 = IP总长度 + IP 首部长度 + TCP 首部长度`
  TCP的数据长度可以直接计算出来，IP长度，TCP首部长度都是已知的，不用专门设置一个字段来存储
- UDP的数据长度也可以这样计算，为什么还要设置一个包长度？
  为了处理方便，首部长度要是4的整数倍，加入包长度是为了补全UDP首部长度 4  整数倍





**四次挥手**







### TCP如何保证可靠传输
1. **校验和**：校验和需要一致，才能传输成功
   发送方：在发送数据之前计算检验和，并进行校验和的填充。
   接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对
2. **确认应答、序列号**：进行传输时，会进行确认应答和数据编号
    - `确认应答`：每次收到数据，都要向发送方进行确认应答-->发送ACK报文，ACK中包含一个确认号ack，ack告诉发送方：已收到了哪些数据，下一次从哪开始发送
    - `序列号`：	对每个字节的 数据进行编号，就是序列号
3. **超时重传**：超过指定的时间没有收到对方的ACK确认报文，会重新发送
   没有收到ACK可能的原因：
   ①网络原因 全体丢包  ②接收端已经收到了数据，但是ACK报文由于网络原因丢失了

   超时的最大时间是动态计算的，累计到一定重传次数，任务网络异常，强制关闭连接
5. **三次握手、四次挥手**
6. **流量控制**（滑动窗口）：根据接收端的能力进行发送数据包
7. **拥塞控制**：先发送小数据去探路，防止拥塞


### TCP报文头部格式
看握手挥手前，先了解TCP报文的头部格式
![在这里插入图片描述](https://img-blog.csdnimg.cn/165bb7290f21408c9c9a713ecd319787.png)


- 序列号：建立连接时初始化的随机值，每发一次，累加一次 `数据字节数`。解决乱序问题 。
- 确认号ack：下一次`期望`收到的序列号，确认该序号之前的数据已经被接收。解决丢包问题。
- ACK：为1表示有效，为0忽略该字段
- RST：为1表示出现异常，重置连接
- SYN：为1表示发起新连接
- FIN：释放连接

**关于ack与ACK**
- ack：下一次期望收到的序列号，也就是`seq + 1`
- ACK：确认连接

### <font color='red'>三次握手

三次握手的**目的**就是要**确认两台设备之间是否具有接收和发送数据的能力**，不能只是单方面接收or发送

如何来保证双方都能收发数据呢？


![在这里插入图片描述](https://img-blog.csdnimg.cn/c0bd3a4b54f645c2bde2ec21ba944522.png)

1. **第一次握手**：验证客户端发送能力和服务端接收能力
   客户端向服务端发起建立连接的请求，随机生成一个序列号x作为seq，将SYN置为1（表示发起连接），将报文发给服务端
2. **第二次握手**：验证服务端的发送能力
   服务端收到报文，发现SYN=1，知道了客户端想要建立连接，将客户端发过来的序列号x保存，随机生成一个发往客户端的序列号y作为seq，将SYN置为1，ACK置为1，ack=x+1,将报文发送给客户端
4. **第三次握手**：验证客户端的接收能力
   客户端收到ACK=1,ack=x+1，知道了服务端收到了完整的报文
   发现SYN=1，知道了服务端同意建立本次连接
   将服务端收到的`seq=y`保存，发送`ACK=1，ack=y+1，seq=x+1`
   seq=x+1,是因为，第一次握手发送ACK报文占据一个序列号，本次从+1开始
   服务端收到报文后发现ACK=1，ack=x+1：知道客户端收到了服务端的确认，本次连接建立


==不携带数据的ACK报文不占据序列号，也就是第三次握手的ACK不占用seq
建立连接后，第一次正式发送数据时，seq还是第一次握手时的seq+1==

### <font color='red'>四次挥手



![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/70d2d9a540588775d0b9e80d59b69b3f.webp?x-oss-process=image/format,png)
假设客户端发送的seq=x，服务端发送的seq=y。
TCP建立连接后客户端总共发送了m个字节的数据
服务端在客户端发FIN报文前总共回复了n个字节的数据
1. **第一次挥手**：
   客户端请求释放连接，发送FIN报文，`FIN=1，seq=u`
   这里的`u=x+m+1`，也就是第一次握手时的序列号+1+客户端发送的数据量
   1是建立连接时占据的一个序列号
2. **第二次挥手**
   服务端收到FIN后，向客户端发送确认报文，`ACK=1,seq=v,ack=u+1`
   `v=y+n`,这时服务端处于关闭等待状态，需要等数据发送完后，再向客户端发送FIN报文
3. **第三次挥手**
   服务端发送完数据后，向客户端发出FIN报文，`FIN=1,ACK=1,seq=w,ack=u+1`
   `w = y+n+最后发送的数据量`
5. **第四次挥手**
   客户端收到FIN报文后，向服务端发送确认报文，`ACK=1,seq=u+1,ack=w+1`
   客户端确认报文发出后，不是马上释放连接，要经过2MSL（也就是2倍的最长报文段寿命）后再释放连接，服务端收到ACK确认后，会立刻释放连接

注意：
<font color='red'>①客户端发出FIN报文段后不能再发送数据，可以接收数据
②FIN报文段不携带数据也要占据一个序列号
③服务端释放连接比客户端要早</font>
### <font color='red'>为什么TCP连接设计为3次？
**1. 阻止过期连接的建立
2. 同步通信双方的初始序列号
3. 避免资源浪费**

1.<font color='blue'>阻止历史重复连接初始化</font>

客户端发起多次连接请求，因为网络原因，旧的SYN报文比新的SYN报文先送达服务端，**只有两次握手的话，服务端无法判断这是过期的连接还是新的连接**，因此需要第三次握手，客户端根据发来的报文和自身的上下文判断，如果是过期连接，就发送RST报文给服务端，中止本次连接

2.<font color='blue'>同步双方的初始序列号</font>

TCP是可靠的通信协议，通信双方需要维护一个<font color='blue'> 序列号</font>
- 接收方可以去除重复的数据
- 接受方可以根据序列号按顺序接收
- 可以标记哪些是已经发送的，哪些是被对方接收的

**如果只有两次握手，只能保证客户端的发送能力和服务端的接受能力
无法验证客户端是否接收到，服务端是否发送出去**

3.<font color='blue'>避免资源浪费</font>

如果是两次握手，当客户端的SYN报文在网络中阻塞，客户端没有收到ACK确认报文，就会重新发送SYN报文，两次握手服务端无法知道客户端是否收到了自己的确认连接ACK，每次收到SYN都会建立一个连接，这样在服务器中生成多个冗余的无效连接，造成了资源的浪费，所以三次握手是保证建立可靠连接的最小次数。

### <font color='red'>半连接队列与全连接队列
- syns queue ：半连接队列。保存SYN-SENT、SYN-RCVD状态的连接
- accept queue ：全连接队列。保存established状态，还没有被accept()调用的连接
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/a7f0e3d2ac9d4effb4765c5a63b39833.png)
  第一次握手：服务端收到SYN，将未建立的连接放入半连接队列
  第二次握手：服务端发送SYN,ACK
  第三次握手：服务端收到客户端的ACK，如果全连接队列没有满，就将半连接队列中的连接放入全连接队列，如果已经满了，就拒绝本次连接


### <font color='red'>什么是SYN洪泛攻击？如何防御SYN攻击？
**SYN攻击**：短时间内伪造大量不存在的IP地址，向服务端发送SYN报文，服务端每次接收到一个SYN，就会放入半连接队列中，由于IP不存在，服务端发送出去SYN+ACK报文，无法获取来自客户端的ACK响应，大量的连接处于SYN-RCVD状态，半连接队列满后，就会无法处理正常的连接请求。


**防御SYN攻击**：
- **缩短超时时间**
- **增加最大半连接队列的大小**
- **SYN cookie 技术**
  服务端收到SYN报文返回一个SYN+ACK时，根据SYN报文计算出一个cookie值，`收到客户端的ACK报文时，不直接分配数据区，而是根据cookie值检查该ACK包的合法性`，如果验证是合法的，再分配专门的数据区进行将来的连接
  linux中查看SYN相关配置：`sysctl -a | grep syn`

### <font color='red'>三次握手中为什么只有第三次可以携带数据？
前两次握手都发送SYN报文

第一次握手携带数据容易被攻击，攻击者在SYN中放如大量数据，重复发送SYN报文，服务端要耗费大龄资源去接收

第三次握手，客户端处于established状态，知道啦服务端的收发能力是正常的，可以携带数据发送

### <font color='red'>为什么关闭连接要挥手4次？
服务端和客户端都没有数据发送时，才可以关闭TCP的连接。

客户端发送FIN报文，表示客户端已经没有数据要向服务端发了，但是客户端不知道服务端还有没有数据向自己发送，服务端收到客户端的FIN报文后，回复ACK确认报文，表示自己收到了释放连接请求，但是自己还有数据没有发完，等数据发完后再发送FIN报文给客户端，表示自己同意释放本次连接，最后客户端再给服务端一个ACK确认报文。

### <font color='red'>TIME_WAIT和CLOSE_WAIT的区别?
- TIME_WAIT 出现在**主动断开连接**的一方，等待2MSL后才关闭连接
- CLOSE_WAIT 出现在**被动断开连接**的一方，直接关闭连接

**TIME_WAIT**：解决对方没有收到第四次挥手的报文的情况。第四次挥手后，如果对方没有收到报文，就会重新发送第三次报文，等待响应，2MSL之后关闭连接

**CLOSE_WAIT**：收到FIN报文后，发送ACK确认，还有数据要发送就会进入CLOSE_WAIT状态


### <font color='red'>为什么第四次挥手后，客户单要等2MSL的时间才释放TCP连接？
MSL（Maximum Segment Lifetime）最大报文生存时间。一次握手、挥手、收发数据的最大时间就是MSL

如果第四次挥手的报文丢失，服务端没有收到确认报文，就会重新发送第三次握手的FIN报文，等待客户端确认，一来一回的最长时间就是2倍的MSL，所以需要等待2MSL后来确认服务端收到了确认报文

### <font color='red'>如果已经建立了连接，客户端突然故障了怎么办？
TCP中有一个**保活机制**
定义一个保活的时间段，在时间段内，服务端没有收到数据，就会，每隔一段时间发送一个**探测报文**，连发几次探测后没有收到客户端的响应，服务端就知道了客户端发生故障，关闭本次连接